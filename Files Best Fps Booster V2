loadstring(game:HttpGet("https://raw.githubusercontent.com/AMOGUS392/Fps-Booster-V2/refs/heads/main/OMS.lua", true))()
local ObjectPool = {}
ObjectPool.__index = ObjectPool

local function safeClone(template)
    local success, result = pcall(function()
        return template:Clone()
    end)
    return success and result or nil
end

local function safeDestroy(obj)
    pcall(function()
        obj:Destroy()
    end)
end

local function isValidObject(obj)
    if not obj then return false end
    
    local success = pcall(function()
        local _ = obj.ClassName
    end)
    
    return success
end

local function resetParticleEmitter(emitter)
    pcall(function()
        emitter.Enabled = false
        
        if emitter.Clear then
            emitter:Clear()
        end
    end)
end

local function resetBeam(beam)
    pcall(function()
        beam.Enabled = false
        
        if beam.Clear then
            beam:Clear()
        end
        
        beam.Attachment0 = nil
        beam.Attachment1 = nil
    end)
end

local function resetTrail(trail)
    pcall(function()
        trail.Enabled = false
        
        if trail.Clear then
            trail:Clear()
        end
        
        trail.Attachment0 = nil
        trail.Attachment1 = nil
    end)
end

local function resetLegacyEffect(effect)
    pcall(function()
        effect.Enabled = false
    end)
end

local function resetAllEffects(obj)
    pcall(function()
        for _, child in ipairs(obj:GetDescendants()) do
            local className = child.ClassName
            
            if className == "ParticleEmitter" then
                resetParticleEmitter(child)
            elseif className == "Beam" then
                resetBeam(child)
            elseif className == "Trail" then
                resetTrail(child)
            elseif className == "Fire" or className == "Smoke" or className == "Sparkles" then
                resetLegacyEffect(child)
            end
        end
    end)
end

function ObjectPool.new(template, initialSize, maxSize, resetFunction)
    if not template or not pcall(function() return template.ClassName end) then
        return nil
    end
    
    maxSize = maxSize and maxSize > 0 and maxSize or 100
    
    local self = setmetatable({}, ObjectPool)
    
    self.template = template
    self.maxSize = maxSize
    self.resetFunction = resetFunction
    
    self.available = {}
    self.activeObjects = {}
    self.activeCount = 0
    self.isInitializing = false
    self._destroyed = false
    
    self.stats = {
        totalGets = 0,
        totalReturns = 0,
        cacheHits = 0,
        newCreations = 0,
        resetErrors = 0,
    }
    
    initialSize = math.clamp(initialSize or 0, 0, maxSize)
    
    for i = 1, initialSize do
        local obj = safeClone(template)
        if obj then
            obj.Parent = nil
            resetAllEffects(obj)
            table.insert(self.available, obj)
        end
    end
    
    return self
end

function ObjectPool.newAsync(template, initialSize, maxSize, resetFunction, yieldInterval)
    local self = ObjectPool.new(template, 0, maxSize, resetFunction)
    if not self then return nil end
    
    initialSize = math.clamp(initialSize or 0, 0, maxSize)
    self.isInitializing = true
    
    task.spawn(function()
        for i = 1, initialSize do
            if self._destroyed then
                break
            end
            
            if self.activeCount + #self.available >= self.maxSize then
                break
            end
            
            local obj = safeClone(template)
            if obj then
                obj.Parent = nil
                resetAllEffects(obj)
                table.insert(self.available, obj)
            end
            
            if yieldInterval then
                task.wait(yieldInterval)
            else
                task.wait()
            end
        end
        self.isInitializing = false
    end)
    
    return self
end

function ObjectPool:_checkDestroyed()
    return self._destroyed
end

function ObjectPool:Get()
    if self:_checkDestroyed() then
        return nil
    end
    
    self.stats.totalGets += 1
    local obj
    
    while #self.available > 0 do
        obj = table.remove(self.available)
        
        if isValidObject(obj) then
            self.stats.cacheHits += 1
            break
        else
            safeDestroy(obj)
            obj = nil
        end
    end
    
    if not obj and self.activeCount < self.maxSize then
        obj = safeClone(self.template)
        
        if not obj then
            return nil
        end
        
        obj.Parent = nil
        self.stats.newCreations += 1
    end
    
    if not obj then
        return nil
    end
    
    self.activeObjects[obj] = true
    self.activeCount += 1
    
    return obj
end

function ObjectPool:Return(obj)
    if self:_checkDestroyed() then
        return
    end
    
    if not obj or not self.activeObjects[obj] then
        return
    end
    
    if not isValidObject(obj) then
        self.activeObjects[obj] = nil
        self.activeCount -= 1
        safeDestroy(obj)
        return
    end
    
    self.activeObjects[obj] = nil
    self.activeCount -= 1
    
    resetAllEffects(obj)
    
    local resetSuccess = true
    if self.resetFunction then
        local success = pcall(self.resetFunction, obj)
        if not success then
            self.stats.resetErrors += 1
            resetSuccess = false
        end
    end
    
    obj.Parent = nil
    
    if resetSuccess then
        self.stats.totalReturns += 1
        table.insert(self.available, obj)
    else
        safeDestroy(obj)
    end
end

function ObjectPool:GetBatch(count)
    if self:_checkDestroyed() then
        return {}, 0
    end
    
    local batch = table.create(count)
    local actualCount = 0
    
    for i = 1, count do
        local obj = self:Get()
        if obj then
            actualCount += 1
            batch[actualCount] = obj
        else
            break
        end
    end
    
    return batch, actualCount
end

function ObjectPool:ReturnBatch(objectsTable)
    if self:_checkDestroyed() then
        return
    end
    
    for _, obj in ipairs(objectsTable) do
        self:Return(obj)
    end
end

function ObjectPool:GetStats()
    if self:_checkDestroyed() then
        return nil
    end
    
    local hitRate = 0
    if self.stats.totalGets > 0 then
        hitRate = self.stats.cacheHits / self.stats.totalGets
    end
    
    local totalCount = self.activeCount + #self.available
    local pressureRatio = self.activeCount / self.maxSize
    
    local memoryPressure = "low"
    if pressureRatio >= 0.95 then
        memoryPressure = "critical"
    elseif pressureRatio >= 0.75 then
        memoryPressure = "high"
    elseif pressureRatio >= 0.5 then
        memoryPressure = "moderate"
    end
    
    return {
        ActiveCount = self.activeCount,
        InactiveCount = #self.available,
        TotalCount = totalCount,
        MaxSize = self.maxSize,
        HitRate = hitRate,
        MemoryPressure = memoryPressure,
        IsInitializing = self.isInitializing,
        RawStats = self.stats,
    }
end

function ObjectPool:ClearInactive()
    if self:_checkDestroyed() then
        return
    end
    
    for _, obj in ipairs(self.available) do
        safeDestroy(obj)
    end
    table.clear(self.available)
end

function ObjectPool:Destroy()
    if self._destroyed then
        return
    end
    
    self._destroyed = true
    
    for _, obj in ipairs(self.available) do
        safeDestroy(obj)
    end
    table.clear(self.available)
    
    for obj in pairs(self.activeObjects) do
        safeDestroy(obj)
    end
    
    table.clear(self.activeObjects)
    self.activeCount = 0
end

return table.freeze(ObjectPool)
