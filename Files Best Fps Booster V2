loadstring(game:HttpGet("https://raw.githubusercontent.com/AMOGUS392/Fps-Booster-Actor/refs/heads/main/Fps%20Booster%20Actor", true))()
local ObjectPool = {}
ObjectPool.__index = ObjectPool

function ObjectPool.new(template, initialSize, maxSize, resetFunction)
    assert(template, "Template cannot be nil")
    assert(maxSize > 0, "MaxSize must be greater than 0")
    
    local self = setmetatable({}, ObjectPool)
    
    self.template = template
    self.maxSize = maxSize
    self.resetFunction = resetFunction
    
    self.available = {}
    self.activeObjects = {}
    self.activeCount = 0
    self.isInitializing = false
    
    self.stats = {
        totalGets = 0,
        totalReturns = 0,
        cacheHits = 0,
        newCreations = 0,
        resetErrors = 0,
    }
    
    initialSize = math.clamp(initialSize, 0, maxSize)
    
    for i = 1, initialSize do
        local obj = template:Clone()
        obj.Parent = nil
        table.insert(self.available, obj)
    end
    
    return self
end

function ObjectPool.newAsync(template, initialSize, maxSize, resetFunction)
    local self = ObjectPool.new(template, 0, maxSize, resetFunction)
    
    initialSize = math.clamp(initialSize, 0, maxSize)
    self.isInitializing = true
    
    task.spawn(function()
        for i = 1, initialSize do
            if self.activeCount + #self.available >= self.maxSize then
                break
            end
            
            local obj = template:Clone()
            obj.Parent = nil
            table.insert(self.available, obj)
            task.wait()
        end
        self.isInitializing = false
    end)
    
    return self
end

function ObjectPool:Get()
    self.stats.totalGets += 1
    local obj
    
    if #self.available > 0 then
        self.stats.cacheHits += 1
        obj = table.remove(self.available)
    elseif self.activeCount < self.maxSize then
        self.stats.newCreations += 1
        obj = self.template:Clone()
        obj.Parent = nil
    else
        warn("[ObjectPool] Pool for '" .. self.template.Name .. "' has reached maximum size (" .. self.maxSize .. "). Failed to get object.")
        return nil
    end
    
    self.activeObjects[obj] = true
    self.activeCount += 1
    
    return obj
end

function ObjectPool:Return(obj)
    if not obj or not self.activeObjects[obj] then
        return
    end
    
    self.activeObjects[obj] = nil
    self.activeCount -= 1
    
    local resetSuccess = true
    if self.resetFunction then
        local success, err = pcall(self.resetFunction, obj)
        if not success then
            warn("[ObjectPool] Reset function failed:", err)
            self.stats.resetErrors += 1
            resetSuccess = false
        end
    end
    
    obj.Parent = nil
    
    if resetSuccess then
        self.stats.totalReturns += 1
        table.insert(self.available, obj)
    else
        obj:Destroy()
    end
end

function ObjectPool:GetBatch(count)
    local batch = table.create(count)
    local actualCount = 0
    
    for i = 1, count do
        local obj = self:Get()
        if obj then
            actualCount += 1
            batch[actualCount] = obj
        else
            break
        end
    end
    
    return batch, actualCount
end

function ObjectPool:ReturnBatch(objectsTable)
    for _, obj in ipairs(objectsTable) do
        self:Return(obj)
    end
end

function ObjectPool:GetStats()
    local hitRate = 0
    if self.stats.totalGets > 0 then
        hitRate = self.stats.cacheHits / self.stats.totalGets
    end
    
    local totalCount = self.activeCount + #self.available
    local pressureRatio = self.activeCount / self.maxSize
    
    local memoryPressure = "low"
    if pressureRatio >= 0.95 then
        memoryPressure = "critical"
    elseif pressureRatio >= 0.75 then
        memoryPressure = "high"
    elseif pressureRatio >= 0.5 then
        memoryPressure = "moderate"
    end
    
    return {
        ActiveCount = self.activeCount,
        InactiveCount = #self.available,
        TotalCount = totalCount,
        MaxSize = self.maxSize,
        HitRate = hitRate,
        MemoryPressure = memoryPressure,
        IsInitializing = self.isInitializing,
        RawStats = self.stats,
    }
end

function ObjectPool:ClearInactive()
    for _, obj in ipairs(self.available) do
        obj:Destroy()
    end
    table.clear(self.available)
end

function ObjectPool:Destroy()
    self:ClearInactive()
    
    for obj in pairs(self.activeObjects) do
        obj:Destroy()
    end
    
    table.clear(self.activeObjects)
    self.activeCount = 0
end

return table.freeze(ObjectPool)
