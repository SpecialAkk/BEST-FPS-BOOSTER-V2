local O, G, S, V, P, U = {}, game, nil, Vector3.new, CFrame.new, nil;

local srv = {
    "Unknown",
    "RunService",
    "CollectionService",
    "Workspace",
    "Stats",
    "LocalPlayer",
    "Players",
    "HttpService",
    "PhysicsService",
    "ReplicatedStorage"
};

local s1, s2, s3, s4, s5, s6, s7 = G:GetService(srv[2]), G:GetService(srv[3]), G:GetService(srv[4]), G:GetService(srv[5]), G:GetService(srv[7]), G:GetService(srv[9]), G:GetService(srv[10]);
local lP, cam = s5.LocalPlayer, s3.CurrentCamera;
local ip, pc, sp, wt, cr, rs = ipairs, pcall, task.spawn, task.wait, coroutine.create, coroutine.resume;
local mf, mh, me, mm, mx, mc, ms, ma = math.floor, math.huge, math.exp, math.min, math.max, math.clamp, math.sqrt, math.abs;

O.Config = {
    VisualSqr = 250000,
    BigSqr = 250000 * 2.25,
    PhysicsSqr = 350000,
    AnimSqr = 450000,
    TextureSqr = 300000,
    ParticleSqr = 200000,
    SoundSqr = 150000,
    EffectSqr = 180000,
    ScriptSqr = 400000,
    ShadowSqr = 250000,
    Hysterisis = 1,
    GridSize = 1500,
    UpdateFrequency = 0.3,
    MaxObjectsPerUpdate = 400,
    DebugMode = false,
    ParticleScaleMin = 0.1,
    OcclusionRays = 2,
    OcclusionSampleSize = 3,
    OcclusionThreshold = 1,
    DynamicLimit = 2000,  -- Will be calculated
    QualityLevel = "High",
    EnableOcclusionCull = true,
    EnableEventDriven = true,
    CameraMoveThreshold = 50,
    EnableMeshConvert = true,
    MeshSimplifyLevel = 2,
    UseTransparencyCull = true,
    UseHybridCull = true,
    MaxVisParts = 200  -- New: Limit visParts per model
};

local qualityMultipliers = {Low = 0.5, Medium = 0.75, High = 1}
local qm = qualityMultipliers[O.Config.QualityLevel] or 1
for k, v in pairs(O.Config) do
    if string.find(k, "Sqr") then O.Config[k] = v * qm end
end

O = {_r = false};
O.U = {};

function O.U.v(o)
    return o and o.Parent and o:IsDescendantOf(G)
end

function O.U.iv(p)
    if not p then return false end
    local size = p.Size / 2
    local cframe = p.CFrame
    local corners = {
        cframe * V(size.X, size.Y, size.Z),
        cframe * V(size.X, size.Y, -size.Z),
        cframe * V(size.X, -size.Y, size.Z),
        cframe * V(size.X, -size.Y, -size.Z),
        cframe * V(-size.X, size.Y, size.Z),
        cframe * V(-size.X, size.Y, -size.Z),
        cframe * V(-size.X, -size.Y, size.Z),
        cframe * V(-size.X, -size.Y, -size.Z),
    }
    local vSize = cam.ViewportSize
    for i = 1, #corners do
        local vp, onScreen = cam:WorldToViewportPoint(corners[i])
        if onScreen and vp.Z > 0 and vp.X > 0 and vp.X < vSize.X and vp.Y > 0 and vp.Y < vSize.Y then
            return true
        end
    end
    return false
end

O.M1 = {
    P = {
        [1] = {f = 70, p = 50},
        [2] = {f = 45, p = 40},
        [3] = {f = 35, p = 30},
        [4] = {f = 25, p = 20}
    },
    a = {r = 1, p = 1, e = 1, d = 1, c = 1, v = 1, ef = 1},
    af = 60,
    i = 0,
    s = "Normal",
    cs = 0,
    BD = 5,
    RF = 50,
    EF = 38
};

function O.M1:u(dt)
    local cf = 1 / dt
    self.i = self.i * 0.95 + ma(cf - self.af) * 0.05
    self.af = self.af * 0.97 + cf * 0.03
    local s, af = self.s, self.af
    if s == "Normal" then
        if af < self.EF and self.i > 12 then
            self.s = "Emergency"
        end
    elseif s == "Emergency" then
        if af > self.RF and self.i < 8 then
            self.s = "Cooldown"
            self.cs = os.clock()
        end
    elseif s == "Cooldown" then
        if af < self.EF and self.i > 12 then
            self.s = "Emergency"
        elseif os.clock() - self.cs > self.BD then
            self.s = "Normal"
        end
    end
    local p = self.P[4]
    if af > self.P[1].f then
        p = self.P[1]
    elseif af > self.P[2].f then
        p = self.P[2]
    elseif af > self.P[3].f then
        p = self.P[3]
    end
    local pf = s3:GetRealPhysicsFPS() or 60
    local rs, ps = af / p.f, pf / p.p
    local iF = 1 + mc(self.i / 20, 0, 1)
    local a = 0.15 + 0.2 * (self.s == "Emergency" and 1 or 0)
    local function ct(v)
        if v < 0.75 then return 4
        elseif v < 0.9 then return 3
        else return 1 end
    end
    local nr, np = ct(rs), ct(ps)
    local ag = self.a
    ag.r = ag.r + (nr * iF - ag.r) * a
    ag.p = ag.p + (np * iF - ag.p) * a
    ag.e = ag.e + (nr * iF - ag.e) * a
    ag.d = ag.d + (nr * iF - ag.d) * a
    ag.c = ag.c + (nr - ag.c) * a
    ag.v = ag.v + (nr * iF - ag.v) * a
    ag.ef = ag.ef + (nr * iF - ag.ef) * a
    
    if O.Config.DebugMode and os.clock() % 10 < dt then
        warn("Current FPS:", math.round(af), "Mode:", s)
    end
end

O.M4 = {t = {}, ti = 1, b = 0.005, phase = 0, lastCamPos = cam.CFrame.Position, lastTriggerTime = 0};

function O.M4:a(t)
    table.insert(self.t, t)
end

function O.M4:s()
    if not O.Config.EnableEventDriven then
        s1.RenderStepped:Connect(function(dt)
            local st = os.clock()
            local i = 0
            local dynamic_b = O.M1.s == "Emergency" and 0.015 or self.b
            while os.clock() - st < dynamic_b and i < #self.t do
                local task = self.t[self.ti]
                if task then
                    if i % 2 == self.phase % 2 then
                        local s, e = pc(task.fn, task.m)
                        if not s then warn("Optimizer Error in " .. (task.name or "unknown") .. ": " .. e) end
                    end
                end
                self.ti = (self.ti % #self.t) + 1
                i = i + 1
            end
            self.phase = (self.phase + 1) % 2
        end)
        return
    end
    
    local function triggerUpdate()
        local now = os.clock()
        if now - self.lastTriggerTime < 0.1 then return end
        self.lastTriggerTime = now
        local currentPos = cam.CFrame.Position
        local delta = (currentPos - self.lastCamPos).Magnitude
        if delta > O.Config.CameraMoveThreshold or O.M1.s == "Emergency" then
            self.lastCamPos = currentPos
            local st = os.clock()
            local i = 0
            local dynamic_b = O.M1.s == "Emergency" and 0.015 or self.b
            while os.clock() - st < dynamic_b and i < #self.t do
                local task = self.t[self.ti]
                if task then
                    if i % 2 == self.phase % 2 then
                        local s, e = pc(task.fn, task.m)
                        if not s then warn("Optimizer Error in " .. (task.name or "unknown") .. ": " .. e) end
                    end
                end
                self.ti = (self.ti % #self.t) + 1
                i = i + 1
            end
            self.phase = (self.phase + 1) % 2
        end
    end
    
    cam:GetPropertyChangedSignal("CFrame"):Connect(triggerUpdate)
    s1.Heartbeat:Connect(function(dt)
        if O.M1.af < O.M1.EF then triggerUpdate() end
    end)
end

O.M5 = {GS = O.Config.GridSize, g = {}, tr = setmetatable({}, {__mode = "k"})};

function O.M5:a(o, d)
    if not O.U.v(o) or not o:IsA("BasePart") then return end
    local s = self.GS
    local p = o.Position
    local k = mf(p.X / s) .. " " .. mf(p.Y / s) .. " " .. mf(p.Z / s)
    self.g[k] = self.g[k] or {}
    table.insert(self.g[k], o)
    self.tr[o] = d
    d.gk = k
end

function O.M5:q(p, r)
    local res = {}
    local s = self.GS
    local R = mf(r / s) + 1
    local cx, cy, cz = mf(p.X / s), mf(p.Y / s), mf(p.Z / s)
    for i = cx - R, cx + R do
        for j = cy - R, cy + R do
            for k = cz - R, cz + R do
                local c = self.g[i .. " " .. j .. " " .. k]
                if c then
                    for l = 1, #c do
                        res[#res + 1] = c[l]
                    end
                end
            end
        end
    end
    return res
end

function O.M5:rm(o)
    local d = self.tr[o]
    if d and d.gk then
        local c = self.g[d.gk]
        if c then
            for i = #c, 1, -1 do
                if c[i] == o then
                    c[i] = c[#c]
                    c[#c] = nil
                    break
                end
            end
            if #c == 0 then self.g[d.gk] = nil end
        end
    end
    self.tr[o] = nil
end

O.MR = setmetatable({}, {__mode = "k"});

local meshIdMap = {
    [Enum.PartShape.Ball] = "rbxassetid://16606212",
    [Enum.PartShape.Cylinder] = "rbxassetid://1033714",
    -- Добавьте другие формы по необходимости
};

function O:rO(m)
    if not O.U.v(m) or not m:IsA("Model") or O.MR[m] then return end
    local pP = m.PrimaryPart
    if not pP then return end
    local d = {
        m = m,
        pP = pP,
        l = {z = 1, lz = 1, lc = 0},
        ph = {s = false, simplified = false, p = {}},
        visParts = {},
        a = {c = nil, h = nil, f = false},
        e = {p = {}, a = true},
        ms = {l = {}},
        snd = {l = {}},
        sc = {l = {}, a = true},
        sh = {p = {}, s = true},
        originalParent = m.Parent,
        isCharacter = m:FindFirstChild("HumanoidRootPart") ~= nil
    }
    local convertible = {}
    local desc = m:GetDescendants()
    for i = 1, #desc do
        local p = desc[i]
        if p:IsA("BasePart") then
            table.insert(d.visParts, p)
            if not p.Anchored and O.Config.EnableMeshConvert and p:IsA("Part") and p.Shape ~= Enum.PartShape.Block then
                table.insert(convertible, p)
            end
        end
    end
    for _, p in ipairs(convertible) do
        local originalParent = p.Parent
        local originalCanCollide = p.CanCollide
        local originalCastShadow = p.CastShadow
        local originalShape = p.Shape
        local mesh = Instance.new("MeshPart")
        mesh.Size = p.Size
        mesh.CFrame = p.CFrame
        mesh.Material = p.Material
        mesh.Color = p.Color
        mesh.Transparency = p.Transparency
        mesh.Reflectance = p.Reflectance
        mesh.CastShadow = p.CastShadow
        mesh.Anchored = p.Anchored
        mesh.CanCollide = p.CanCollide
        mesh.Name = p.Name
        mesh.MeshId = meshIdMap[originalShape] or ""
        mesh.CollisionFidelity = Enum.CollisionFidelity.Box
        if O.Config.MeshSimplifyLevel > 1 then
            mesh.Size = mesh.Size * 0.9
        end
        for _, child in ipairs(p:GetChildren()) do
            child.Parent = mesh
        end
        p:Destroy()
        mesh.Parent = originalParent
        d.ph.p[#d.ph.p + 1] = {p = mesh, originalCanCollide = originalCanCollide}
        if originalCastShadow then
            d.sh.p[#d.sh.p + 1] = {p = mesh, os = true}
        end
        if p == pP then
            d.pP = mesh
            m.PrimaryPart = mesh
        end
        if O.Config.DebugMode then warn("Converted to MeshPart:", mesh.Name) end
    end
    -- Refresh desc after conversions
    desc = m:GetDescendants()
    for i = 1, #desc do
        local p = desc[i]
        if p:IsA("BasePart") then
            if not table.find(d.visParts, p) then
                table.insert(d.visParts, p)
            end
            if not p.Anchored then
                if not table.find(d.ph.p, p) then
                    table.insert(d.ph.p, {p = p, originalCanCollide = p.CanCollide})
                end
            end
            if p.CastShadow then
                if not table.find(d.sh.p, p) then
                    table.insert(d.sh.p, {p = p, os = true})
                end
            end
            if p.Velocity.Magnitude < 1 and not p.Anchored then
                p.Anchored = true
            end
        end
        if p:IsA("MeshPart") and p.TextureID ~= "" then
            table.insert(d.ms.l, {p = p, t = p.TextureID})
        end
        if p:IsA("ParticleEmitter") or p:IsA("Light") or p:IsA("Beam") or p:IsA("Trail") or p:IsA("Attachment") then
            local prop = p:IsA("Attachment") and "Visible" or "Enabled"
            local state = p[prop]
            local rate = p:IsA("ParticleEmitter") and p.Rate or nil
            table.insert(d.e.p, {e = p, prop = prop, state = state, rate = rate})
        end
        if p:IsA("Sound") then
            table.insert(d.snd.l, {s = p, op = p.Playing})
        end
        -- Convert legacy Fire/Smoke for TSB effects
        if p:IsA("Fire") then
            local emitter = Instance.new("ParticleEmitter")
            emitter.Parent = p.Parent
            emitter.Rate = p.Heat * 2
            emitter.Speed = NumberRange.new(p.Size, p.Size * 1.5)
            emitter:Enabled = p.Enabled
            p:Destroy()
            table.insert(d.e.p, {e = emitter, prop = "Enabled", state = emitter.Enabled, rate = emitter.Rate})
        end
        if p:IsA("Smoke") then
            local emitter = Instance.new("ParticleEmitter")
            emitter.Parent = p.Parent
            emitter.Rate = p.RiseVelocity * 2
            emitter.Speed = NumberRange.new(p.Size, p.Size * 1.5)
            emitter:Enabled = p.Enabled
            p:Destroy()
            table.insert(d.e.p, {e = emitter, prop = "Enabled", state = emitter.Enabled, rate = emitter.Rate})
        end
    end
    local h = m:FindFirstChildOfClass("Humanoid")
    if h then
        d.a.h = h
        d.a.c = h:FindFirstChildOfClass("Animator")
    end
    O.MR[m] = d
    O.M5:a(d.pP, d)
    m.Destroying:Connect(function() O:urO(m) end)
end

function O:urO(m)
    local d = O.MR[m]
    if d then O.M5:rm(d.pP) end
    O.MR[m] = nil
end

local function getNearby(cP, sqr)  
    local nb = O.M5:q(cP, ms(sqr) + O.Config.GridSize / 2)
    if not nb then return {} end  -- Fix nil
    table.sort(nb, function(a, b)
        return (a.Position - cP).MagnitudeSquared < (b.Position - cP).MagnitudeSquared
    end)
    if #nb > O.Config.DynamicLimit then
        local limited = {}
        for i=1, O.Config.DynamicLimit do limited[i] = nb[i] end
        nb = limited
    end
    return nb
end

function O.M6:u()
    local ag = O.M1.a.r
    local cP = cam.CFrame.Position
    local VS = O.Config.VisualSqr / (ag * ag)
    local BS = VS * 2.25
    local H = O.Config.Hysterisis
    local nb = getNearby(cP, BS)
    local maxPerUpdate = O.Config.MaxObjectsPerUpdate
    local processed = 0
    local useOcclusion = O.Config.EnableOcclusionCull and O.M1.af > 30
    local rays = useOcclusion and (O.M1.s == "Emergency" and 1 or O.Config.OcclusionRays) or 0
    local sampleSize = useOcclusion and (O.M1.s == "Emergency" and 1 or O.Config.OcclusionSampleSize) or 0
    local loopStart = os.clock()
    for i = 1, #nb do
        if processed >= maxPerUpdate or os.clock() - loopStart > 0.01 then break end
        local pP = nb[i]
        local d = O.M5.tr[pP]
        if d and O.U.v(d.m) then
            if d.isCharacter then continue end
            local dS = (pP.Position - cP).MagnitudeSquared
            if dS > BS then continue end
            local isVisibleOnScreen = false
            local visibleParts = {}
            local visCount = #d.visParts
            if visCount > 50 then
                if O.M1.af < 40 then continue end  -- Skip large in low FPS
                visCount = 50  -- Limit checks
            end
            for j = 1, visCount do
                local vp = d.visParts[j]
                if O.U.v(vp) and O.U.iv(vp) then
                    isVisibleOnScreen = true
                    table.insert(visibleParts, vp.Position)
                end
            end
            local occluded = false
            if useOcclusion and isVisibleOnScreen then
                sp(function()
                    local function isOccluded(pos)
                        local origin = cam.CFrame.Position
                        local dir = (pos - origin).Unit
                        local magnitude = (pos - origin).Magnitude
                        local rayParams = RaycastParams.new()
                        rayParams.FilterType = Enum.RaycastFilterType.Exclude
                        rayParams.FilterDescendantsInstances = {lP.Character}
                        for j = 1, rays do
                            local offset = dir:Cross(V(0,1,0)).Unit * (j - rays / 2) * 0.5
                            local result = s3:Raycast(origin + offset, dir * magnitude, rayParams)
                            if result and not result.Instance:IsDescendantOf(d.m) then return true end
                        end
                        return false
                    end
                    local occlSample = math.min(#visibleParts, sampleSize)
                    local occludedCount = 0
                    for j = 1, occlSample do
                        if isOccluded(visibleParts[j]) then
                            occludedCount = occludedCount + 1
                        end
                    end
                    occluded = (occludedCount / occlSample >= O.Config.OcclusionThreshold)
                end)
            end
            local l = d.l
            local tZ = 1
            if useOcclusion and (not isVisibleOnScreen or occluded) then
                tZ = 3
            elseif dS > BS then tZ = 3
            elseif dS > VS then tZ = 2 end
            if l.z ~= tZ and os.clock() - l.lc > H then
                l.lz = l.z
                l.z = tZ
                l.lc = os.clock()
                task.defer(function()
                    local trans = (tZ == 3 or tZ == 2) and 1 or 0
                    for _, vp in ipairs(d.visParts) do
                        if O.U.v(vp) then vp.LocalTransparencyModifier = trans end
                    end
                    if O.Config.UseHybridCull and tZ == 3 then
                        d.m.Parent = nil
                    end
                    if tZ == 2 then
                        for _, vp in ipairs(d.visParts) do
                            if O.U.v(vp) then vp.LocalTransparencyModifier = 0.5 end
                        end
                    end
                end)
            end
            if l.z == 1 then
                local tr = mc(dS / VS, 0, 0.9)
                local f = dS < VS * 0.4 and 0 or 2
                task.defer(function()
                    for _, vp in ipairs(d.visParts) do
                        if O.U.v(vp) then
                            vp.LocalTransparencyModifier = tr
                            if vp.RenderFidelity.Value ~= f then
                                vp.RenderFidelity = Enum.RenderFidelity.FromValue(f)
                            end
                        end
                    end
                end)
            end
            local shFar = dS > O.Config.ShadowSqr / (ag * ag)
            if d.sh.s ~= shFar then
                d.sh.s = shFar
                task.defer(function()
                    for j = 1, #d.sh.p do
                        local sd = d.sh.p[j]
                        if O.U.v(sd.p) then
                            sd.p.CastShadow = not shFar and sd.os or false
                        end
                    end
                end)
            end
            processed = processed + 1
            if O.Config.DebugMode and processed > 800 then warn("High process count in LOD:", processed) end
        end
    end
end

function O.M7:u()
    local ag = O.M1.a.p
    local cP = cam.CFrame.Position
    local SS = O.Config.PhysicsSqr / (ag * ag)
    local op_name, df_name = O.cg.op_name, O.cg.df_name
    local nb = getNearby(cP, SS)
    local maxPerUpdate = O.Config.MaxObjectsPerUpdate
    local processed = 0
    local loopStart = os.clock()
    for i = 1, #nb do
        if processed >= maxPerUpdate or os.clock() - loopStart > 0.01 then break end
        local pP = nb[i]
        local d = O.M5.tr[pP]
        if d and O.U.v(d.m) then
            local dS = (pP.Position - cP).MagnitudeSquared
            if dS > SS then continue end
            local ph = d.ph
            local sS = dS > SS
            local gridKey = d.gk
            local cellCount = # (O.M5.g[gridKey] or {})
            local simplify = O.Config.EnableMeshConvert and cellCount > 500 and O.M1.s == "Emergency"
            local changed = ph.s ~= sS or ph.simplified ~= simplify
            if changed then
                ph.s = sS
                ph.simplified = simplify
                local g = sS and op_name or df_name
                local useOriginal = not sS and not simplify
                task.defer(function()
                    for j = 1, #ph.p do
                        local pd = ph.p[j]
                        if O.U.v(pd.p) then
                            pd.p.CollisionGroup = g
                            pd.p.CanCollide = useOriginal and pd.originalCanCollide or false
                            pd.p.CanTouch = pd.p.CanCollide
                            pd.p.CanQuery = pd.p.CanCollide
                        end
                    end
                end)
            end
            processed = processed + 1
        end
    end
end

function O.M15:u()
    local ag = O.M1.a.p
    local cP = cam.CFrame.Position
    local FS = O.Config.AnimSqr / (ag * ag)
    local nb = getNearby(cP, FS)
    local maxPerUpdate = O.Config.MaxObjectsPerUpdate
    local processed = 0
    local loopStart = os.clock()
    for i = 1, #nb do
        if processed >= maxPerUpdate or os.clock() - loopStart > 0.01 then break end
        local pP = nb[i]
        local d = O.M5.tr[pP]
        if d and O.U.v(d.m) then
            local dS = (pP.Position - cP).MagnitudeSquared
            if dS > FS then continue end
            local a = d.a
            if a.c then
                local sF = dS > FS
                if a.f ~= sF then
                    a.f = sF
                    if O.U.v(a.c) then a.c.Enabled = not sF end
                    if O.U.v(a.h) then a.h.PlatformStand = sF end
                end
            end
            processed = processed + 1
        end
    end
end

function O.M16:u()
    local ag = O.M1.a.d
    local cP = cam.CFrame.Position
    local NTS = O.Config.TextureSqr / (ag * ag)
    local nb = getNearby(cP, NTS)
    local maxPerUpdate = O.Config.MaxObjectsPerUpdate
    local processed = 0
    local loopStart = os.clock()
    for i = 1, #nb do
        if processed >= maxPerUpdate or os.clock() - loopStart > 0.01 then break end
        local pP = nb[i]
        local d = O.M5.tr[pP]
        if d and O.U.v(d.m) and #d.ms.l > 0 then
            local dS = (pP.Position - cP).MagnitudeSquared
            if dS > NTS then continue end
            local nT = dS > NTS
            task.defer(function()
                for j = 1, #d.ms.l do
                    local md = d.ms.l[j]
                    if O.U.v(md.p) then
                        local tT = nT and "" or md.t
                        if md.p.TextureID ~= tT then
                            md.p.TextureID = tT
                        end
                    end
                end
            end)
            processed = processed + 1
        end
    end
end

function O.M17:u()
    local ag = O.M1.a.ef
    local cP = cam.CFrame.Position
    local PS = O.Config.ParticleSqr / (ag * ag)
    local nb = getNearby(cP, PS)
    local maxPerUpdate = O.Config.MaxObjectsPerUpdate
    local processed = 0
    local fpsScale = mc(O.M1.af / 60, O.Config.ParticleScaleMin, 1)
    local extraScale = processed > 500 and 0.5 or 1
    local loopStart = os.clock()
    for i = 1, #nb do
        if processed >= maxPerUpdate or os.clock() - loopStart > 0.01 then break end
        local pP = nb[i]
        local d = O.M5.tr[pP]
        if d and O.U.v(d.m) and #d.e.p > 0 then
            local distSqr = (pP.Position - cP).MagnitudeSquared
            if distSqr > PS then continue end
            local far = distSqr > PS
            local scale = far and 0 or mc(1 - (distSqr / PS), O.Config.ParticleScaleMin, 1) * fpsScale * extraScale
            if d.e.a ~= (scale > 0) then
                d.e.a = scale > 0
            end
            task.defer(function()
                for j = 1, #d.e.p do
                    local ed = d.e.p[j]
                    if O.U.v(ed.e) then
                        ed.e[ed.prop] = scale > 0 and ed.state or false
                        if ed.rate then ed.e.Rate = ed.rate * scale end
                        if ed.e:IsA("ParticleEmitter") then
                            ed.e.Size = NumberRange.new(ed.e.Size.Min * scale, ed.e.Size.Max * scale)  -- Scale size for lag reduction
                        end
                    end
                end
            end)
            processed = processed + 1
        end
    end
end

function O.M18:u()
    local ag = O.M1.a.c
    local cP = cam.CFrame.Position
    local SNS = O.Config.SoundSqr / (ag * ag)
    local nb = getNearby(cP, SNS)
    local maxPerUpdate = O.Config.MaxObjectsPerUpdate
    local processed = 0
    local loopStart = os.clock()
    for i = 1, #nb do
        if processed >= maxPerUpdate or os.clock() - loopStart > 0.01 then break end
        local pP = nb[i]
        local d = O.M5.tr[pP]
        if d and O.U.v(d.m) and #d.snd.l > 0 then
            local dS = (pP.Position - cP).MagnitudeSquared
            if dS > SNS then continue end
            local far = dS > SNS
            task.defer(function()
                for j = 1, #d.snd.l do
                    local sd = d.snd.l[j]
                    if O.U.v(sd.s) then
                        if far and sd.s.Playing then
                            sd.s:Pause()
                        elseif not far and not sd.s.Playing and sd.op then
                            sd.s:Resume()
                        end
                    end
                end
            end)
            processed = processed + 1
        end
    end
end

function O.M19:u()
    local ag = O.M1.a.v
    local cP = cam.CFrame.Position
    local SCS = O.Config.ScriptSqr / (ag * ag)
    local nb = getNearby(cP, SCS)
    local maxPerUpdate = O.Config.MaxObjectsPerUpdate
    local processed = 0
    local loopStart = os.clock()
    for i = 1, #nb do
        if processed >= maxPerUpdate or os.clock() - loopStart > 0.01 then break end
        local pP = nb[i]
        local d = O.M5.tr[pP]
        if d and O.U.v(d.m) then
            local dS = (pP.Position - cP).MagnitudeSquared
            if dS > SCS then continue end
            local far = dS > SCS
            if #d.sc.l == 0 then
                local desc = d.m:GetDescendants()
                for j = 1, #desc do
                    local s = desc[j]
                    if s:IsA("LocalScript") then
                        d.sc.l[#d.sc.l + 1] = {s = s, od = s.Disabled}
                    end
                end
            end
            if d.sc.a ~= not far then
                d.sc.a = not far
                task.defer(function()
                    for j = 1, #d.sc.l do
                        local sd = d.sc.l[j]
                        if O.U.v(sd.s) then
                            sd.s.Disabled = far or sd.od
                        end
                    end
                end)
            end
            processed = processed + 1
        end
    end
end

function O.M21:u()
    local lighting = G:GetService("Lighting")
    local lights = lighting:GetChildren()
    local decals = s3:GetDescendants()
    local cP = cam.CFrame.Position
    task.defer(function()
        for _, light in ipairs(lights) do
            if light:IsA("Light") and light.Parent and light.Parent:IsA("BasePart") then
                local distSqr = (light.Parent.Position - cP).MagnitudeSquared
                light.Enabled = distSqr < O.Config.EffectSqr
            end
        end
        for _, decal in ipairs(decals) do
            if (decal:IsA("Decal") or decal:IsA("Texture")) and decal.Parent and decal.Parent:IsA("BasePart") then
                local distSqr = (decal.Parent.Position - cP).MagnitudeSquared
                decal.Transparency = (distSqr > O.Config.TextureSqr) and 1 or 0
            end
        end
    end)
end

-- New: Batching for drawcalls and shadows from DevForum
function O.M22:u()
    local cP = cam.CFrame.Position
    local nb = getNearby(cP, O.Config.VisualSqr)
    if O.M1.s ~= "Emergency" then return end  -- Only in low FPS
    task.defer(function()
        for i = 1, #nb do
            local pP = nb[i]
            local d = O.M5.tr[pP]
            if d and O.U.v(d.m) and #d.visParts > 10 then  -- For large models
                local parts = {}
                for _, vp in ipairs(d.visParts) do
                    if vp.Size.Magnitude < 5 then  -- Small parts
                        table.insert(parts, vp)
                    end
                end
                if #parts > 0 then
                    local union = Instance.new("UnionOperation")
                    union.UsePartColor = true
                    union.CollisionFidelity = Enum.CollisionFidelity.Box
                    union.Parent = d.m
                    for _, p in ipairs(parts) do
                        p.Parent = union
                    end
                    union = union:UnionAsync(parts)  -- Correct async
                    -- Replace visParts with union
                    d.visParts = {union}
                end
            end
            -- Disable shadows for far
            local dS = (pP.Position - cP).MagnitudeSquared
            if dS > O.Config.ShadowSqr then
                for j = 1, #d.sh.p do
                    local sd = d.sh.p[j]
                    if O.U.v(sd.p) then sd.p.CastShadow = false end
                end
            end
        end
    end)
end

-- New: Foliage optimization from DevForum
function O.M23:u()
    local cP = cam.CFrame.Position
    local foliage = s2:GetTagged("Foliage")
    if O.M1.s ~= "Emergency" then return end
    task.defer(function()
        for _, fol in ipairs(foliage) do
            if fol:IsA("Model") then
                local dS = (fol.PrimaryPart.Position - cP).MagnitudeSquared
                if dS > O.Config.VisualSqr then
                    fol.Parent = nil  -- Cull far foliage
                elseif dS > O.Config.TextureSqr then
                    for _, leaf in ipairs(fol:GetDescendants()) do
                        if leaf:IsA("BasePart") then leaf.TextureID = "" end
                        leaf.CastShadow = false
                    end
                end
                if #fol:GetChildren() > 20 then
                    local parts = fol:GetDescendants()
                    local smallParts = {}
                    for _, leaf in ipairs(parts) do
                        if leaf:IsA("BasePart") and leaf.Size.Magnitude < 2 then
                            table.insert(smallParts, leaf)
                        end
                    end
                    if #smallParts > 0 then
                        local union = Instance.new("UnionOperation")
                        union.UsePartColor = true
                        union.CollisionFidelity = Enum.CollisionFidelity.Box
                        union.Parent = fol
                        for _, p in ipairs(smallParts) do
                            p.Parent = union
                        end
                        union = union:UnionAsync(smallParts)  -- Correct async
                    end
                end
            end
        end
    end)
end

-- New: Terrain and storage optimization from DevForum
function O.M24:u()
    local cP = cam.CFrame.Position
    task.defer(function()
        -- Remove unseen terrain
        local terrain = s3.Terrain
        local viewRegion = Region3.new(cP - V(500, 500, 500), cP + V(500, 500, 500))
        terrain:ClearAllChildren()  -- Careful, this clears all, use for specific
        -- Store non-essential in ServerStorage
        local nonEssential = s2:GetTagged("NonEssential")
        for _, ne in ipairs(nonEssential) do
            local dS = (ne.Position - cP).MagnitudeSquared
            if dS > O.Config.VisualSqr then
                ne.Parent = G.ServerStorage
            end
        end
        -- Use materials over textures
        for _, part in ipairs(s3:GetDescendants()) do
            if part:IsA("BasePart") and #part:GetChildren("Texture") > 0 then
                part.Material = Enum.Material.Grass  -- Example, adapt
                for _, tex in ipairs(part:GetChildren("Texture")) do tex:Destroy() end
            end
        end
    end)
end

-- New: Part pooling from DevForum
O.PartPool = {}  -- Global pool
function O.M25:u()  -- Pool manager
    if O.M1.s ~= "Emergency" then return end
    task.defer(function()
        -- Example pooling: Create pool of 100 parts
        if #O.PartPool < 100 then
            for i = 1, 100 do
                local part = Instance.new("Part")
                part.Anchored = true
                part.CanCollide = false
                part.Parent = O.hiddenFolder
                table.insert(O.PartPool, part)
            end
        end
        -- Re-use from pool for new objects (assume in game logic)
        -- When done: part.Parent = O.hiddenFolder to return to pool
    end)
end

-- New: Ability effects optimization for TSB
function O.M28:u()
    local cP = cam.CFrame.Position
    local abilities = s2:GetTagged("AbilityEffect")
    task.defer(function()
        for _, ab in ipairs(abilities) do
            local dS = (ab.Position - cP).MagnitudeSquared
            if dS > O.Config.EffectSqr then
                ab.Enabled = false
            elseif dS > O.Config.ParticleSqr then
                if ab:IsA("ParticleEmitter") then ab.Rate = ab.Rate * 0.5 end
            else
                ab.Enabled = true
            end
        end
    end)
end

function O:A()
    -- Calculate dynamic limit
    local total_parts = 0
    local managed = s2:GetTagged("Managed")
    for _, model in ipairs(managed) do
        for _, inst in ipairs(model:GetDescendants()) do
            if inst:IsA("BasePart") then total_parts = total_parts + 1 end
        end
    end
    if total_parts > 10000 then
        O.Config.DynamicLimit = total_parts / 10
    else
        O.Config.DynamicLimit = math.clamp(total_parts / 5, 500, 10000)
    end
    if O.Config.DebugMode then warn("Dynamic Limit set to:", O.Config.DynamicLimit) end

    if not s3.StreamingEnabled then
        s3.StreamingEnabled = true
    end
    O.os = Instance.new("Folder")
    O.os.Name = "Z_S"
    O.os.Parent = s3
    O.hiddenFolder = Instance.new("Folder")
    O.hiddenFolder.Name = "HiddenCull"
    O.hiddenFolder.Parent = s7  -- ReplicatedStorage
    O.cg = {op_name = "O_P", df_name = "Default"}
    s6:CreateCollisionGroup(O.cg.op_name)
    s6:CollisionGroupSetCollidable(O.cg.op_name, O.cg.df_name, false)
    local function ot(i)
        if i:IsA("Model") then O:rO(i) end
    end
    local tagged = s2:GetTagged("Managed")
    task.spawn(function()
        for _, i in ipairs(tagged) do
            ot(i)
            task.wait(0.01)
        end
    end)
    s2:GetInstanceAddedSignal("Managed"):Connect(ot)
    s2:GetInstanceRemovedSignal("Managed"):Connect(function(i)
        if i:IsA("Model") then O:urO(i) end
    end)
    task.delay(1, function() O._r = true end)
    s1.Heartbeat:Connect(function(dt)
        if O._r then O.M1:u(dt) end
    end)
    O.M4:a({name = "LOD", m = O.M6, fn = O.M6.u})
    O.M4:a({name = "PHY", m = O.M7, fn = O.M7.u})
    O.M4:a({name = "ANI", m = O.M15, fn = O.M15.u})
    O.M4:a({name = "MSH", m = O.M16, fn = O.M16.u})
    O.M4:a({name = "PRT", m = O.M17, fn = O.M17.u})
    O.M4:a({name = "SND", m = O.M18, fn = O.M18.u})
    O.M4:a({name = "SCR", m = O.M19, fn = O.M19.u})
    O.M4:a({name = "LGT", m = O.M21, fn = O.M21.u})
    O.M4:a({name = "BAT", m = O.M22, fn = O.M22.u})
    O.M4:a({name = "FOL", m = O.M23, fn = O.M23.u})
    O.M4:a({name = "TER", m = O.M24, fn = O.M24.u})
    O.M4:a({name = "POOL", m = O.M25, fn = O.M25.u})
    O.M4:a({name = "ABL", m = O.M28, fn = O.M28.u})  -- New abilities module
    O.M4:s()
end

O:A()
