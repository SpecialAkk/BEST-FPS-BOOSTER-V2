local ObjectPool = {}
ObjectPool.__index = ObjectPool

local function createPool(template: Instance, initialSize: number, maxSize: number, resetFunction: ((obj: Instance) -> ())?)
	assert(typeof(template) == "Instance", "Template must be an Instance")
	assert(typeof(initialSize) == "number" and initialSize >= 0, "initialSize must be a non-negative number")
	assert(typeof(maxSize) == "number" and maxSize >= initialSize, "maxSize must be greater than or equal to initialSize")

	local pool = setmetatable({}, ObjectPool)

	pool._template = template
	pool._maxSize = maxSize
	pool._resetFunction = resetFunction
	pool._inactiveObjects = {}
	pool._activeObjects = {}

	pool._stats = {
		totalGets = 0,
		totalReturns = 0,
		cacheHits = 0,
		newCreations = 0,
	}

	return pool
end

function ObjectPool.new(template: Instance, initialSize: number, maxSize: number, resetFunction: ((obj: Instance) -> ())?)
	local pool = createPool(template, initialSize, maxSize, resetFunction)

	for i = 1, initialSize do
		local newObj = template:Clone()
		newObj.Parent = nil
		table.insert(pool._inactiveObjects, newObj)
	end

	return pool
end

function ObjectPool.newAsync(template: Instance, initialSize: number, maxSize: number, resetFunction: ((obj: Instance) -> ())?)
	local pool = createPool(template, initialSize, maxSize, resetFunction)

	task.spawn(function()
		for i = 1, initialSize do
			local newObj = template:Clone()
			newObj.Parent = nil
			table.insert(pool._inactiveObjects, newObj)
			task.wait()
		end
	end)

	return pool
end

function ObjectPool:Get()
	self._stats.totalGets += 1
	local obj = table.remove(self._inactiveObjects)

	if obj then
		self._stats.cacheHits += 1
	elseif #self._activeObjects < self._maxSize then
		self._stats.newCreations += 1
		obj = self._template:Clone()
		obj.Parent = nil
	else
		warn("[ObjectPool] Пул для '"..self._template.Name.."' достиг максимального размера (" .. tostring(self._maxSize) .. "). Не удалось получить объект.")
		return nil
	end
	
	self._activeObjects[obj] = true
	return obj
end

function ObjectPool:Return(obj: Instance)
	if not self._activeObjects[obj] then
		warn("[ObjectPool] Попытка вернуть в пул объект, который не принадлежит этому пулу или уже возвращен.", obj)
		return
	end

	self._stats.totalReturns += 1
	self._activeObjects[obj] = nil
	table.insert(self._inactiveObjects, obj)

	if self._resetFunction then
		self._resetFunction(obj)
	end

	obj.Parent = nil
end

function ObjectPool:GetBatch(count: number)
	local batch = {}
	for i = 1, count do
		local obj = self:Get()
		if obj then
			table.insert(batch, obj)
		else
			break
		end
	end
	return batch
end

function ObjectPool:ReturnBatch(objectsTable: {Instance})
	for _, obj in ipairs(objectsTable) do
		self:Return(obj)
	end
end

function ObjectPool:GetStats()
	local activeCount = 0
	for _ in pairs(self._activeObjects) do
		activeCount += 1
	end
	
	local inactiveCount = #self._inactiveObjects
	local totalCount = activeCount + inactiveCount
	
	local hitRate = 0
	if self._stats.totalGets > 0 then
		hitRate = self._stats.cacheHits / self._stats.totalGets
	end
	
	local pressureRatio = totalCount / self._maxSize
	local memoryPressure = "low"
	if pressureRatio >= 0.95 then
		memoryPressure = "critical"
	elseif pressureRatio >= 0.75 then
		memoryPressure = "high"
	elseif pressureRatio >= 0.5 then
		memoryPressure = "moderate"
	end

	return {
		ActiveCount = activeCount,
		InactiveCount = inactiveCount,
		TotalCount = totalCount,
		MaxSize = self._maxSize,
		HitRate = hitRate,
		MemoryPressure = memoryPressure,
		RawStats = self._stats,
	}
end

function ObjectPool:ClearInactive()
	for _, obj in ipairs(self._inactiveObjects) do
		obj:Destroy()
	end
	self._inactiveObjects = {}
end

function ObjectPool:Destroy()
	self:ClearInactive()
	for obj in pairs(self._activeObjects) do
		obj:Destroy()
	end
	self._activeObjects = {}
end

return table.freeze(ObjectPool)
