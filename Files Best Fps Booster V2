loadstring(game:HttpGet("https://raw.githubusercontent.com/AMOGUS392/Fps-Booster-V2/refs/heads/main/OMS.lua", true))()
local ObjectPool = {}
ObjectPool.__index = ObjectPool

local function isValidObject(obj: Instance?): boolean
	if not obj then
		return false
	end
	return obj.Parent ~= nil
end

function ObjectPool.new(template: Instance, initialSize: number, maxSize: number, resetFunction: ((Instance) -> ())?): typeof(setmetatable({} :: any, ObjectPool))
	assert(template, "Template cannot be nil")
	assert(typeof(template) == "Instance", "Template must be an Instance")
	assert(maxSize > 0, "MaxSize must be greater than 0")
	
	local self = setmetatable({}, ObjectPool)
	
	self.template = template
	self.maxSize = maxSize
	self.resetFunction = resetFunction
	
	self.available = table.create(maxSize)
	self.activeObjects = {}
	self.activeCount = 0
	self.availableCount = 0
	self.isInitializing = false
	self.isDestroyed = false
	
	self.stats = {
		totalGets = 0,
		totalReturns = 0,
		cacheHits = 0,
		newCreations = 0,
		resetErrors = 0,
		duplicateReturns = 0,
	}
	
	initialSize = math.clamp(initialSize, 0, maxSize)
	
	for i = 1, initialSize do
		local obj = template:Clone()
		obj.Parent = nil
		self.available[i] = obj
	end
	self.availableCount = initialSize
	
	return self
end

function ObjectPool.newAsync(template: Instance, initialSize: number, maxSize: number, resetFunction: ((Instance) -> ())?): typeof(setmetatable({} :: any, ObjectPool))
	local self = ObjectPool.new(template, 0, maxSize, resetFunction)
	
	initialSize = math.clamp(initialSize, 0, maxSize)
	self.isInitializing = true
	
	task.spawn(function()
		local createdCount = 0
		for i = 1, initialSize do
			local currentTotal = self.activeCount + self.availableCount
			if currentTotal >= self.maxSize then
				break
			end
			
			local obj = template:Clone()
			obj.Parent = nil
			self.availableCount += 1
			self.available[self.availableCount] = obj
			createdCount += 1
			
			if createdCount % 10 == 0 then
				task.wait()
			end
		end
		self.isInitializing = false
	end)
	
	return self
end

function ObjectPool:Get(): Instance?
	if self.isDestroyed then
		return nil
	end
	
	self.stats.totalGets += 1
	local obj: Instance?
	
	while self.availableCount > 0 do
		obj = self.available[self.availableCount]
		self.available[self.availableCount] = nil
		self.availableCount -= 1
		
		if isValidObject(obj) then
			self.stats.cacheHits += 1
			break
		else
			obj = nil
		end
	end
	
	if not obj then
		if self.activeCount < self.maxSize then
			self.stats.newCreations += 1
			obj = self.template:Clone()
			obj.Parent = nil
		else
			return nil
		end
	end
	
	self.activeObjects[obj] = true
	self.activeCount += 1
	
	return obj
end

function ObjectPool:Return(obj: Instance?): ()
	if self.isDestroyed then
		if obj and isValidObject(obj) then
			obj:Destroy()
		end
		return
	end
	
	if not obj then
		return
	end
	
	if not self.activeObjects[obj] then
		self.stats.duplicateReturns += 1
		return
	end
	
	self.activeObjects[obj] = nil
	self.activeCount -= 1
	
	if not isValidObject(obj) then
		return
	end
	
	local resetSuccess = true
	if self.resetFunction then
		local success, err = pcall(self.resetFunction, obj)
		if not success then
			self.stats.resetErrors += 1
			resetSuccess = false
			warn("ObjectPool reset error:", err)
		end
	end
	
	obj.Parent = nil
	
	if resetSuccess then
		self.stats.totalReturns += 1
		
		local totalCount = self.activeCount + self.availableCount
		if totalCount < self.maxSize then
			self.availableCount += 1
			self.available[self.availableCount] = obj
		else
			obj:Destroy()
		end
	else
		obj:Destroy()
	end
end

function ObjectPool:GetBatch(count: number): ({Instance}, number)
	assert(count > 0, "Count must be greater than 0")
	
	local batch = table.create(count)
	local actualCount = 0
	
	for i = 1, count do
		local obj = self:Get()
		if obj then
			actualCount += 1
			batch[actualCount] = obj
		else
			break
		end
	end
	
	return batch, actualCount
end

function ObjectPool:ReturnBatch(objectsTable: {Instance}): ()
	if not objectsTable then
		return
	end
	
	for i = 1, #objectsTable do
		self:Return(objectsTable[i])
	end
end

function ObjectPool:GetStats(): {[string]: any}
	local totalCount = self.activeCount + self.availableCount
	local pressureRatio = self.activeCount / self.maxSize
	
	local memoryPressure = "low"
	if pressureRatio >= 0.95 then
		memoryPressure = "critical"
	elseif pressureRatio >= 0.75 then
		memoryPressure = "high"
	elseif pressureRatio >= 0.5 then
		memoryPressure = "moderate"
	end
	
	local hitRate = 0
	if self.stats.totalGets > 0 then
		hitRate = self.stats.cacheHits / self.stats.totalGets
	end
	
	return {
		ActiveCount = self.activeCount,
		InactiveCount = self.availableCount,
		TotalCount = totalCount,
		MaxSize = self.maxSize,
		HitRate = hitRate,
		MemoryPressure = memoryPressure,
		PressureRatio = pressureRatio,
		IsInitializing = self.isInitializing,
		IsDestroyed = self.isDestroyed,
		RawStats = self.stats,
	}
end

function ObjectPool:ClearInactive(): ()
	for i = 1, self.availableCount do
		local obj = self.available[i]
		if obj and isValidObject(obj) then
			obj:Destroy()
		end
	end
	table.clear(self.available)
	self.availableCount = 0
end

function ObjectPool:Destroy(): ()
	if self.isDestroyed then
		return
	end
	
	self.isDestroyed = true
	
	self:ClearInactive()
	
	for obj in self.activeObjects do
		if isValidObject(obj) then
			obj:Destroy()
		end
	end
	
	table.clear(self.activeObjects)
	self.activeCount = 0
	
	table.clear(self.stats)
	
	setmetatable(self, nil)
end

function ObjectPool:CleanupDeadObjects(): ()
	local writeIndex = 0
	for i = 1, self.availableCount do
		local obj = self.available[i]
		if obj and isValidObject(obj) then
			writeIndex += 1
			self.available[writeIndex] = obj
		end
	end
	
	for i = writeIndex + 1, self.availableCount do
		self.available[i] = nil
	end
	self.availableCount = writeIndex
	
	local validActiveCount = 0
	for obj in self.activeObjects do
		if not isValidObject(obj) then
			self.activeObjects[obj] = nil
		else
			validActiveCount += 1
		end
	end
	self.activeCount = validActiveCount
end

function ObjectPool:SetMaxSize(newMaxSize: number): ()
	assert(newMaxSize > 0, "MaxSize must be greater than 0")
	
	self.maxSize = newMaxSize
	
	while self.availableCount > 0 and (self.activeCount + self.availableCount) > self.maxSize do
		local obj = self.available[self.availableCount]
		self.available[self.availableCount] = nil
		self.availableCount -= 1
		
		if obj and isValidObject(obj) then
			obj:Destroy()
		end
	end
end

function ObjectPool:Prewarm(count: number): ()
	count = math.clamp(count, 0, self.maxSize - self.activeCount - self.availableCount)
	
	for i = 1, count do
		local obj = self.template:Clone()
		obj.Parent = nil
		self.availableCount += 1
		self.available[self.availableCount] = obj
	end
end

function ObjectPool:PrewarmAsync(count: number): ()
	task.spawn(function()
		count = math.clamp(count, 0, self.maxSize - self.activeCount - self.availableCount)
		
		for i = 1, count do
			local obj = self.template:Clone()
			obj.Parent = nil
			self.availableCount += 1
			self.available[self.availableCount] = obj
			
			if i % 10 == 0 then
				task.wait()
			end
		end
	end)
end

function ObjectPool:Shrink(): ()
	self:ClearInactive()
end

return table.freeze(ObjectPool)
