loadstring(game:HttpGet("https://raw.githubusercontent.com/AMOGUS392/Fps-Booster-V2/refs/heads/main/OMS.lua", true))()
local ObjectPool = {}
ObjectPool.__index = ObjectPool

local math_clamp = math.clamp
local table_clear = table.clear
local table_create = table.create

local function resetParticleEmitter(emitter)
    emitter.Enabled = false
    emitter:Clear()
end

local function resetBeam(beam)
    beam.Enabled = false
    beam:Clear()
    beam.Attachment0 = nil
    beam.Attachment1 = nil
end

local function resetTrail(trail)
    trail.Enabled = false
    trail:Clear()
    trail.Attachment0 = nil
    trail.Attachment1 = nil
end

local function resetLegacyEffect(effect)
    effect.Enabled = false
end

local effect_resetters = {
    ParticleEmitter = resetParticleEmitter,
    Beam = resetBeam,
    Trail = resetTrail,
    Fire = resetLegacyEffect,
    Smoke = resetLegacyEffect,
    Sparkles = resetLegacyEffect
}

local function scanEffects(obj)
    local effects
    local count = 0
    local descendants = obj:GetDescendants()
    local desc_count = #descendants
    
    for i = 1, desc_count do
        local desc = descendants[i]
        local resetter = effect_resetters[desc.ClassName]
        if resetter then
            if not effects then
                effects = table_create(8)
            end
            count = count + 1
            effects[count] = {effect = desc, reset = resetter}
        end
    end
    
    return effects
end

local function resetEffects(effects)
    if not effects then return end
    local effect_count = #effects
    for i = 1, effect_count do
        local data = effects[i]
        if data.effect.Parent then
            data.reset(data.effect)
        end
    end
end

function ObjectPool.new(template, initialSize, maxSize, resetFunction)
    if not template then return nil end
    
    local success, className = pcall(function() return template.ClassName end)
    if not success then return nil end
    
    maxSize = maxSize and maxSize > 0 and maxSize or 100
    initialSize = math_clamp(initialSize or 0, 0, maxSize)
    
    local self = setmetatable({}, ObjectPool)
    
    self.template = template
    self.maxSize = maxSize
    self.resetFunction = resetFunction
    
    self.available = table_create(maxSize)
    self.availableCount = 0
    self.activeObjects = {}
    self.activeCount = 0
    self.effectCache = {}
    self._destroyed = false
    
    self.stats = {
        totalGets = 0,
        totalReturns = 0,
        cacheHits = 0,
        newCreations = 0,
        resetErrors = 0
    }
    
    for i = 1, initialSize do
        local success, obj = pcall(template.Clone, template)
        if success and obj then
            obj.Parent = nil
            local effects = scanEffects(obj)
            if effects then
                resetEffects(effects)
                self.effectCache[obj] = effects
            end
            self.availableCount = self.availableCount + 1
            self.available[self.availableCount] = obj
        end
    end
    
    return self
end

function ObjectPool.newAsync(template, initialSize, maxSize, resetFunction, yieldInterval)
    local self = ObjectPool.new(template, 0, maxSize, resetFunction)
    if not self then return nil end
    
    initialSize = math_clamp(initialSize or 0, 0, maxSize)
    
    task.spawn(function()
        for i = 1, initialSize do
            if self._destroyed then break end
            if self.activeCount + self.availableCount >= self.maxSize then break end
            
            local success, obj = pcall(template.Clone, template)
            if success and obj then
                obj.Parent = nil
                local effects = scanEffects(obj)
                if effects then
                    resetEffects(effects)
                    self.effectCache[obj] = effects
                end
                self.availableCount = self.availableCount + 1
                self.available[self.availableCount] = obj
            end
            
            if yieldInterval then
                task.wait(yieldInterval)
            else
                task.wait()
            end
        end
    end)
    
    return self
end

function ObjectPool:Get()
    if self._destroyed then return nil end
    
    self.stats.totalGets = self.stats.totalGets + 1
    local obj
    
    while self.availableCount > 0 do
        obj = self.available[self.availableCount]
        self.available[self.availableCount] = nil
        self.availableCount = self.availableCount - 1
        
        if obj.Parent == nil then
            self.stats.cacheHits = self.stats.cacheHits + 1
            break
        else
            obj:Destroy()
            self.effectCache[obj] = nil
            obj = nil
        end
    end
    
    if not obj and self.activeCount < self.maxSize then
        local success, result = pcall(self.template.Clone, self.template)
        if success and result then
            obj = result
            obj.Parent = nil
            self.stats.newCreations = self.stats.newCreations + 1
            
            local effects = scanEffects(obj)
            if effects then
                self.effectCache[obj] = effects
            end
        end
    end
    
    if not obj then return nil end
    
    self.activeObjects[obj] = true
    self.activeCount = self.activeCount + 1
    
    return obj
end

function ObjectPool:Return(obj)
    if self._destroyed or not obj or not self.activeObjects[obj] then return end
    
    self.activeObjects[obj] = nil
    self.activeCount = self.activeCount - 1
    
    if obj.Parent ~= nil then
        obj:Destroy()
        self.effectCache[obj] = nil
        return
    end
    
    local effects = self.effectCache[obj]
    if not effects then
        effects = scanEffects(obj)
        if effects then
            self.effectCache[obj] = effects
        end
    end
    
    if effects then
        resetEffects(effects)
    end
    
    local resetSuccess = true
    if self.resetFunction then
        local success = pcall(self.resetFunction, obj)
        if not success then
            self.stats.resetErrors = self.stats.resetErrors + 1
            resetSuccess = false
        end
    end
    
    obj.Parent = nil
    
    if resetSuccess and self.availableCount < self.maxSize then
        self.stats.totalReturns = self.stats.totalReturns + 1
        self.availableCount = self.availableCount + 1
        self.available[self.availableCount] = obj
    else
        obj:Destroy()
        self.effectCache[obj] = nil
    end
end

function ObjectPool:GetBatch(count)
    if self._destroyed then return {}, 0 end
    
    local batch = table_create(count)
    local actualCount = 0
    
    for i = 1, count do
        local obj = self:Get()
        if obj then
            actualCount = actualCount + 1
            batch[actualCount] = obj
        else
            break
        end
    end
    
    return batch, actualCount
end

function ObjectPool:ReturnBatch(objectsTable)
    if self._destroyed then return end
    
    local batch_count = #objectsTable
    for i = 1, batch_count do
        self:Return(objectsTable[i])
    end
end

function ObjectPool:GetStats()
    if self._destroyed then return nil end
    
    local hitRate = self.stats.totalGets > 0 and (self.stats.cacheHits / self.stats.totalGets) or 0
    local totalCount = self.activeCount + self.availableCount
    local pressureRatio = self.activeCount / self.maxSize
    
    local memoryPressure = pressureRatio >= 0.95 and "critical"
        or pressureRatio >= 0.75 and "high"
        or pressureRatio >= 0.5 and "moderate"
        or "low"
    
    return {
        ActiveCount = self.activeCount,
        InactiveCount = self.availableCount,
        TotalCount = totalCount,
        MaxSize = self.maxSize,
        HitRate = hitRate,
        MemoryPressure = memoryPressure,
        RawStats = self.stats
    }
end

function ObjectPool:ClearInactive()
    if self._destroyed then return end
    
    for i = 1, self.availableCount do
        local obj = self.available[i]
        if obj then
            obj:Destroy()
            self.effectCache[obj] = nil
        end
    end
    
    table_clear(self.available)
    self.availableCount = 0
end

function ObjectPool:Destroy()
    if self._destroyed then return end
    self._destroyed = true
    
    for i = 1, self.availableCount do
        local obj = self.available[i]
        if obj then
            obj:Destroy()
        end
    end
    
    for obj in self.activeObjects do
        obj:Destroy()
    end
    
    table_clear(self.available)
    table_clear(self.activeObjects)
    table_clear(self.effectCache)
    self.availableCount = 0
    self.activeCount = 0
end

return table.freeze(ObjectPool)
