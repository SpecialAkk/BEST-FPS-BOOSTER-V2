loadstring(game:HttpGet("https://raw.githubusercontent.com/AMOGUS392/Fps-Booster-V2/refs/heads/main/OMS.lua", true))()
local ObjectPool = {}
ObjectPool.__index = ObjectPool

function ObjectPool.new(template, initialSize, maxSize, resetFunction)
    assert(template, "Template cannot be nil")
    assert(typeof(template) == "Instance", "Template must be an Instance")
    assert(maxSize > 0, "MaxSize must be greater than 0")
    
    local self = setmetatable({}, ObjectPool)
    
    self.template = template
    self.maxSize = maxSize
    self.resetFunction = resetFunction
    
    self.available = {}
    self.activeObjects = setmetatable({}, { __mode = "k" })
    self.activeCount = 0
    self.isInitializing = false
    self.isDestroyed = false
    
    self.stats = {
        totalGets = 0,
        totalReturns = 0,
        cacheHits = 0,
        newCreations = 0,
        resetErrors = 0,
        duplicateReturns = 0,
    }
    
    initialSize = math.clamp(initialSize, 0, maxSize)
    
    for i = 1, initialSize do
        local obj = template:Clone()
        obj.Parent = nil
        table.insert(self.available, obj)
    end
    
    return self
end

function ObjectPool.newAsync(template, initialSize, maxSize, resetFunction)
    local self = ObjectPool.new(template, 0, maxSize, resetFunction)
    
    initialSize = math.clamp(initialSize, 0, maxSize)
    self.isInitializing = true
    
    task.spawn(function()
        local createdCount = 0
        for i = 1, initialSize do
            local currentTotal = self.activeCount + #self.available
            if currentTotal >= self.maxSize then
                break
            end
            
            local obj = template:Clone()
            obj.Parent = nil
            table.insert(self.available, obj)
            createdCount += 1
            
            if createdCount % 10 == 0 then
                task.wait()
            end
        end
        self.isInitializing = false
    end)
    
    return self
end

local function isValidObject(obj)
    if not obj then
        return false
    end
    
    local success = pcall(function()
        return obj.Parent
    end)
    
    return success
end

function ObjectPool:Get()
    if self.isDestroyed then
        return nil
    end
    
    self.stats.totalGets += 1
    local obj
    
    while #self.available > 0 do
        obj = table.remove(self.available)
        
        if isValidObject(obj) then
            self.stats.cacheHits += 1
            break
        else
            obj = nil
        end
    end
    
    if not obj then
        local actualActiveCount = 0
        for _ in self.activeObjects do
            actualActiveCount += 1
        end
        self.activeCount = actualActiveCount
        
        if self.activeCount < self.maxSize then
            self.stats.newCreations += 1
            obj = self.template:Clone()
            obj.Parent = nil
        else
            return nil
        end
    end
    
    self.activeObjects[obj] = true
    self.activeCount += 1
    
    return obj
end

function ObjectPool:Return(obj)
    if self.isDestroyed then
        if isValidObject(obj) then
            obj:Destroy()
        end
        return
    end
    
    if not obj then
        return
    end
    
    if not self.activeObjects[obj] then
        self.stats.duplicateReturns += 1
        return
    end
    
    if not isValidObject(obj) then
        self.activeObjects[obj] = nil
        self.activeCount -= 1
        return
    end
    
    self.activeObjects[obj] = nil
    self.activeCount -= 1
    
    local resetSuccess = true
    if self.resetFunction then
        local success, err = pcall(self.resetFunction, obj)
        if not success then
            self.stats.resetErrors += 1
            resetSuccess = false
        end
    end
    
    obj.Parent = nil
    
    if resetSuccess then
        self.stats.totalReturns += 1
        
        if self.activeCount + #self.available < self.maxSize then
            table.insert(self.available, obj)
        else
            obj:Destroy()
        end
    else
        obj:Destroy()
    end
end

function ObjectPool:GetBatch(count)
    assert(count > 0, "Count must be greater than 0")
    
    local batch = {}
    local actualCount = 0
    
    for i = 1, count do
        local obj = self:Get()
        if obj then
            actualCount += 1
            batch[actualCount] = obj
        else
            break
        end
    end
    
    return batch, actualCount
end

function ObjectPool:ReturnBatch(objectsTable)
    if not objectsTable then
        return
    end
    
    for i = 1, #objectsTable do
        self:Return(objectsTable[i])
    end
end

function ObjectPool:GetStats()
    local actualActiveCount = 0
    for _ in self.activeObjects do
        actualActiveCount += 1
    end
    self.activeCount = actualActiveCount
    
    local hitRate = 0
    if self.stats.totalGets > 0 then
        hitRate = self.stats.cacheHits / self.stats.totalGets
    end
    
    local totalCount = self.activeCount + #self.available
    local pressureRatio = self.activeCount / self.maxSize
    
    local memoryPressure = "low"
    if pressureRatio >= 0.95 then
        memoryPressure = "critical"
    elseif pressureRatio >= 0.75 then
        memoryPressure = "high"
    elseif pressureRatio >= 0.5 then
        memoryPressure = "moderate"
    end
    
    return {
        ActiveCount = self.activeCount,
        InactiveCount = #self.available,
        TotalCount = totalCount,
        MaxSize = self.maxSize,
        HitRate = hitRate,
        MemoryPressure = memoryPressure,
        IsInitializing = self.isInitializing,
        IsDestroyed = self.isDestroyed,
        RawStats = self.stats,
    }
end

function ObjectPool:ClearInactive()
    for i = #self.available, 1, -1 do
        local obj = self.available[i]
        if isValidObject(obj) then
            obj:Destroy()
        end
    end
    table.clear(self.available)
end

function ObjectPool:Destroy()
    if self.isDestroyed then
        return
    end
    
    self.isDestroyed = true
    
    self:ClearInactive()
    
    for obj in self.activeObjects do
        if isValidObject(obj) then
            obj:Destroy()
        end
    end
    
    table.clear(self.activeObjects)
    self.activeCount = 0
    
    table.clear(self.stats)
    
    setmetatable(self, nil)
end

function ObjectPool:CleanupDeadObjects()
    local validAvailable = {}
    for _, obj in self.available do
        if isValidObject(obj) then
            table.insert(validAvailable, obj)
        end
    end
    self.available = validAvailable
    
    local actualActiveCount = 0
    for obj in self.activeObjects do
        if isValidObject(obj) then
            actualActiveCount += 1
        end
    end
    self.activeCount = actualActiveCount
end

function ObjectPool:SetMaxSize(newMaxSize)
    assert(newMaxSize > 0, "MaxSize must be greater than 0")
    
    self.maxSize = newMaxSize
    
    while #self.available > 0 and (self.activeCount + #self.available) > self.maxSize do
        local obj = table.remove(self.available)
        if isValidObject(obj) then
            obj:Destroy()
        end
    end
end

function ObjectPool:Prewarm(count)
    count = math.clamp(count, 0, self.maxSize - self.activeCount - #self.available)
    
    for i = 1, count do
        local obj = self.template:Clone()
        obj.Parent = nil
        table.insert(self.available, obj)
    end
end

function ObjectPool:PrewarmAsync(count)
    task.spawn(function()
        count = math.clamp(count, 0, self.maxSize - self.activeCount - #self.available)
        
        for i = 1, count do
            local obj = self.template:Clone()
            obj.Parent = nil
            table.insert(self.available, obj)
            
            if i % 10 == 0 then
                task.wait()
            end
        end
    end)
end

return table.freeze(ObjectPool)
